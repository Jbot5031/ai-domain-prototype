# app.py

from fastapi import FastAPI
from apscheduler.schedulers.background import BackgroundScheduler
from datetime import datetime
import random
import sqlite3
from pydantic import BaseModel

app = FastAPI()

# SQLite DB initialization
conn = sqlite3.connect('db.sqlite3')
c = conn.cursor()
c.execute('''CREATE TABLE IF NOT EXISTS domains
             (id INTEGER PRIMARY KEY, name TEXT, valuation_score REAL, acquired_price REAL, target_sell_price REAL, status TEXT)''')
c.execute('''CREATE TABLE IF NOT EXISTS transactions
             (id INTEGER PRIMARY KEY, domain_id INTEGER, type TEXT, amount REAL)''')
conn.commit()

class Domain(BaseModel):
    name: str
    valuation_score: float
    acquired_price: float
    target_sell_price: float

# Domain generator
def generate_fake_domain():
    keywords = ["smart", "green", "fast", "cloud", "crypto"]
    suffixes = [".com", ".net", ".ai"]
    name = random.choice(keywords) + random.choice(keywords)
    return name + random.choice(suffixes)

# Valuation engine
def score_domain(name):
    length = len(name)
    score = max(0, 1 - (length / 20))
    if name.endswith(".com"):
        score += 0.2
    return min(1, score)

# Adding fake domains to database every hour
def add_fake_domain():
    domain_name = generate_fake_domain()
    score = score_domain(domain_name)
    target_price = round(500 + score * 2500, -2)
    c.execute("INSERT INTO domains (name, valuation_score, acquired_price, target_sell_price, status) VALUES (?, ?, ?, ?, ?)",
              (domain_name, score, 100, target_price, "discovered"))
    conn.commit()

# Start adding domains in the background
scheduler = BackgroundScheduler()
scheduler.add_job(add_fake_domain, 'interval', hours=1)
scheduler.start()

@app.get("/domains/")
def get_domains():
    c.execute("SELECT * FROM domains WHERE status='discovered'")
    domains = c.fetchall()
    return {"domains": domains}

@app.post("/buy/")
def buy_domain(domain: Domain):
    c.execute("INSERT INTO domains (name, valuation_score, acquired_price, target_sell_price, status) VALUES (?, ?, ?, ?, ?)",
              (domain.name, domain.valuation_score, domain.acquired_price, domain.target_sell_price, "owned"))
    conn.commit()
    return {"message": f"Bought {domain.name} for {domain.acquired_price}"}

@app.post("/sell/")
def sell_domain(domain_id: int):
    c.execute("SELECT * FROM domains WHERE id=?", (domain_id,))
    domain = c.fetchone()
    if domain:
        profit = domain[3] - domain[2]  # target_sell_price - acquired_price
        c.execute("UPDATE domains SET status=? WHERE id=?", ("sold", domain_id))
        conn.commit()
        return {"message": f"Sold {domain[1]} for {domain[3]} with a profit of {profit}"}
    return {"message": "Domain not found"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)